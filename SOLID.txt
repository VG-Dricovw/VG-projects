SOLID:

S: Single responsibility principle SRP
a class should have one function/job
the class should be applicable as much as possible without adding functions

O: Open/closed principle OCP
the code should be open for extension and closed for modification
what does this mean
when designing a function, think of other uses that it could have.
example: an API that retrieves invoices as PDFs could also be needed to have other filetypes like CSV
when finished ask: can i add a new class/method without changing the existing code?

L: Liskov substitution principle LSP
we can use any inheriting class in place of the base class.
so we must be allowed to add subclasses to change a use of the main class
we should not change how the parent class methods work
dont implement life:code as 1:1 

I: Interface segregation principle ISP
no client should be forced to depend on methods it does not use
interface should not declare multiple methods

D: Dependency inversion principle DIP
high-level modules should not import anything from low-level modules. both shoul depend on abstactions (eg. interfaces)
abstractions should not depend on details. details should depend on abstractions